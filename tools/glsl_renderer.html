<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">

  <title>GLSL Renderer</title>
  <meta name="author" content="Eltaurus">

  <link rel="icon" href="../favicon.svg" type="image/svg+xml">
  <link rel="icon" type="image/svg+xml" href="">
  <link rel="stylesheet" href="../styles/main.css">
  <link rel="stylesheet" href="../styles/Lt.css">

  <style>
    html, body { height: 100%; margin: 0 !important; max-width: unset; padding: 0; outline: unset;}
    .split.v { display: flex; height: 100%; }
    .split.h { display: flex; width: 100%; flex-direction: column;}
    .pane { flex: 1; }
    .pane#rendersettings { flex: 0 0 250px; }
    .pane#glslcode { flex: 0 0 250px; }

    #viewportPane, #codePane { position: relative; padding: 0 1em; }
    #shaderCanvas {
      position: absolute;
      display: block;
      inset: 50%;
      translate: -50% -50%;
      background: black;

      box-shadow: 5px 5px 25px #0005;

      image-rendering: pixelated;   /* nearest-neighbour */
      image-rendering: crisp-edges; /* nearest-neighbour fallback */
    }
    
    #codePane {
      padding: 0;
      background: var(--hover-col);
    }
    #compileButton {
      position: absolute;
      right: 0.5rem;
      top: 0.5rem;
    }
    
    #FileName {
      position: relative;
      z-index: 9999;
    }
    #FileName:not(:focus-visible)::selection {
      background-color: transparent;
    }
  </style>

</head>
<body>
  <div class="split v">
    <div class="split h">
      <div class="pane bg" id="viewportPane">
        <h3 id="FileName" contenteditable="true" spellcheck="false">New File</h3>
        <canvas id="shaderCanvas"></canvas>
      </div>
      <divider></divider>
      <div class="pane" id="codePane">
        <button onclick="compile()" id="compileButton">Compile</button>
        <iframe id="glslcode" src="glsl_editor.html"></iframe>
      </div>
    </div>
    <divider></divider>
    <div class="pane Lt" id="rendersettings">
      <h3>Directory</h3>

      <h3>Dimensions</h3>
      <div class="input-block">
        <input id="widthIn" name="width" type="number" inputmode="numeric" pattern="\d*" min="1" step="1" value="1920" placeholder="px" required />
        <span>/</span>
        <input id="heightIn" name="height" type="number" inputmode="numeric" pattern="\d*" min="1" step="1" value="1080" placeholder="px" required />
      </div>

      <h3>Duration</h3>
      <div class="input-block">
        <input id="secondsIn" name="seconds" type="number" inputmode="numeric" pattern="\d*" min="1" step="1" value="10" placeholder="sec" required />
        <span style="translate: 0 2px">Ã—</span>
        <input id="fpsIn" name="fps" type="number" inputmode="numeric" pattern="\d*" min="1" step="1" value="25" placeholder="fps" required />
        <span style="translate: 0 2px">=</span>
        <input id="framesIn" name="frames" type="number" inputmode="numeric" pattern="\d*" min="1" step="1" value="250" placeholder="frames" required />
      </div>

      <br>

      <div class="progress-bar" id="renderProgress"></div>
      <button onclick="render()" id="renderButton">Render</button>
      <br><br>
      <button onclick="renderFrame()" id="frameButton">Render Frame</button>

    </div>
  </div>

  <script>
    let dragging = false, draggingDir, startCur, startVal;
    [...document.querySelectorAll('.split')].forEach((split) => {
      const divider = split.querySelector(':scope > divider');
      const resizedPane = split.querySelector(':scope > divider + *');

      divider.addEventListener('mousedown', e => {
        dragging = resizedPane;

        if (split.classList.contains("v")) {
          startCur = e.clientX;
          startVal = resizedPane.getBoundingClientRect().width;
          draggingDir = 'h';
        } else {
          startCur = e.clientY;
          startVal = resizedPane.getBoundingClientRect().height;
          draggingDir = 'v';
        }

        window.addEventListener('mousemove', onMove);
        window.addEventListener('mouseup', onUp);
        window.addEventListener('message', onMessage);

      });

    });

    const iframeLs = new Map();
    document.querySelectorAll('iframe').forEach(iframeL => {
      iframeLs.set(iframeL.contentWindow, iframeL); // same-origin only
    });

    function onMessage(e) {
      const iframeL = iframeLs.get(e.source);
    
      switch (e.data.type) {
        case 'mousemove':
          onMove(e.data, iframeL);
          break;
        case 'mouseup':
          onUp();
          break;
      }
    }

    function onMove(e, iframeL = null) {
      if (!dragging) return;
      currentCur = (draggingDir === 'h') ? e.clientX : e.clientY;
      if (iframeL) {
        const origin = iframeL.getBoundingClientRect();
        currentCur += (draggingDir === 'h') ? origin.left : origin.top;
      }
      dragging.style.flex = '0 0 ' + (startVal + startCur - currentCur) + 'px';
    }

    function onUp() {
      dragging = false;
      document.removeEventListener('mousemove', onMove);
      document.removeEventListener('mouseup', onUp);
      document.removeEventListener('message', onMessage);
    }
  </script>

  <script>
    const widthL = document.getElementById('widthIn');
    const heightL = document.getElementById('heightIn');
    const shaderL = document.getElementById('shaderCanvas');
    
    widthL.addEventListener("change", resizeCanvas); // alt: "input" event
    heightL.addEventListener("change", resizeCanvas);

    function resizeCanvas() {
      shaderL.width = widthL.value;
      shaderL.height= heightL.value;
    }
  </script>

  <script>
    var renderInterval;
    const progBtn = document.getElementById("renderButton");
    const progBar = document.getElementById("renderProgress");


    function render() {
      console.log("rendering...");

      progBtn.innerText = "Stop";
      progBtn.onclick = () => stopRender();

      var prog = 0;
      progBar.classList.add("inprogress");
      progBar.classList.remove("done");
      progBar.style.backgroundPosition = `${100 - prog}%`;
      console.log(`progress: ${prog}%`);
      
      renderInterval = setInterval(() => {
        prog += 13.5;

        progBar.style.backgroundPosition = `${100 - prog}%`;
        console.log(`progress: ${prog}%`);

        if (prog >=100) {
          prog = 100;
          progBar.classList.add("done");
          stopRender('done!');
        }
      }, 700);
    }

    function stopRender(msg = 'stopped by user') {
      clearInterval(renderInterval);
      console.log(msg);
      progBtn.innerText = "Render";
      progBtn.onclick = render;
    }
  </script>

  <script>
    const gl = shaderL.getContext('webgl');
    let program = null, iResolutionLoc, iTimeLoc, iFrameLoc;
    let startTime = performance.now();
    let frameCount = 0;

    function displayFrame() {
      if (!program) return;

      gl.viewport(0, 0, shaderL.width, shaderL.height);
      gl.useProgram(program);

      const now = performance.now();
      const time = (now - startTime) * 0.001;

      if (iResolutionLoc) {
        gl.uniform2f(iResolutionLoc, shaderL.width, shaderL.height);
      }
      if (iTimeLoc) {
        gl.uniform1f(iTimeLoc, time);
      }
      if (iFrameLoc) {
        gl.uniform1i(iFrameLoc, frameCount);
      }

      gl.drawArrays(gl.TRIANGLES, 0, 3);
      frameCount++;
      requestAnimationFrame(displayFrame);
    }

    function loadShader(type, source) {
      const shader = gl.createShader(type);
      gl.shaderSource(shader, source);
      gl.compileShader(shader);
      if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
        const info = gl.getShaderInfoLog(shader);
        console.error('Shader compile error:', info);
        gl.deleteShader(shader);
        return null;
      }
      return shader;
    }

    function compile() {
      const code = document.getElementById('glslcode').contentDocument.querySelector('.CodeMirror').CodeMirror.getValue();

      const vertexSource = `
        attribute vec2 aPosition;
        void main() {
          gl_Position = vec4(aPosition, 0.0, 1.0);
        }
      `;

      const fragmentSource = `${code}`;

      // init program
      const vs = loadShader(gl.VERTEX_SHADER, vertexSource);
      const fs = loadShader(gl.FRAGMENT_SHADER, fragmentSource);
      if (!vs || !fs) return;

      program = gl.createProgram();
      gl.attachShader(program, vs);
      gl.attachShader(program, fs);
      gl.linkProgram(program);
      if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
        const info = gl.getProgramInfoLog(program);
        console.error('Program link error:', info);
        gl.deleteProgram(program);
        return;
      }
      gl.useProgram(program);

      const buffer = gl.createBuffer();
      gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
      const vertices = new Float32Array([-1,-1,3,-1,-1,3]);
      gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);

      const aPosition = gl.getAttribLocation(program, 'aPosition');
      gl.enableVertexAttribArray(aPosition);
      gl.vertexAttribPointer(aPosition, 2, gl.FLOAT, false, 0, 0);

      iResolutionLoc = gl.getUniformLocation(program, 'iResolution');
      iTimeLoc       = gl.getUniformLocation(program, 'iTime');
      iFrameLoc      = gl.getUniformLocation(program, 'iFrame');

      requestAnimationFrame(displayFrame);
    }
  </script>

  <script>
    // Viewport navigation

    zoomList = [10, 25, 50, 100, 200, 400, 700, 1000];
    let zoomLevel;
    zoom();
  
    const viewportL = document.getElementById('viewportPane');

    viewportL.addEventListener("wheel", e => {
      zoomLevel -= Math.sign(e.deltaY);
      zoom(zoomLevel);
    });

    function zoom(zoomTarget) {
      if (zoomTarget === undefined) {
        const defaultZoom = 100;
        zoomLevel = 0;
        let closest = Math.abs(zoomList[0] - defaultZoom);
        for (let i = 1; i < zoomList.length; i++) {
          const diff = Math.abs(zoomList[i] - defaultZoom);
          if (diff < closest) {
            closest = diff;
            zoomLevel = i;
          }
        }
      } else {
        zoomLevel = Math.min(Math.max(Math.round(zoomTarget), 0), zoomList.length);
      }
      shaderL.style.scale = `${zoomList[zoomLevel]}%`;
    } 

  </script>

  <script>
    // Keyboard Shortcuts
    window.addEventListener('keydown', (e) => {

      /* avoid triggering when editing text */
      const tag = (e.target.tagName || '').toLowerCase();
      const editable = e.target.isContentEditable || tag === 'input' || tag === 'textarea';

      const ctrlKey = e.ctrlKey || e.metaKey; /* ctrl || mac cmd */
      if (editable && !ctrlKey) return;
      const shiftKey = e.shiftKey;
      const altKey = e.altKey;
      const key = e.key;

      /* Save */
      if (ctrlKey && !shiftKey && key === 's') {
        e.preventDefault();
        console.log('saving...');
        return;
      }

      /* Reset zoom */
      if (altKey && key === 's') {
        e.preventDefault();
        zoom();
        return;
      }

      if (ctrlKey && key === 'Enter') {
        e.preventDefault();
        compile();
        return;
      }

    });
  </script>
</body>
</html>