<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">

  <title>GLSL Renderer</title>
  <meta name="author" content="Eltaurus">

  <link rel="icon" href="../favicon.svg" type="image/svg+xml">
  <link rel="icon" type="image/svg+xml" href="">
  <link rel="stylesheet" href="../styles/main.css">

  <style>
    html, body { height: 100%; margin: 0 !important; max-width: unset; padding: 0; outline: unset;}
    .split.v { display: flex; height: 100%; }
    .split.h { display: flex; width: 100%; flex-direction: column;}
    .pane { flex: 1; }
    .pane#rendersettings { flex: 0 0 250px; }
    .pane#glslcode { flex: 0 0 250px; }

    #shaderPane { position: relative; }
    #shaderCanvas {
      position: absolute;
      display: block;
      inset: 50%;
      translate: -50% -50%;
      background: black;

      box-shadow: 5px 5px 25px #0005;
    }
    
    #glslcode {
      margin: 0;
      background: var(--hover-col);
    }
  </style>

</head>
<body>
  <div class="split v">
    <div class="split h">
      <div class="pane bg" id="shaderPane">
        <canvas id="shaderCanvas"></canvas>
      </div>
      <divider></divider>
      <iframe class="pane" id="glslcode" src="glsl_editor.html"></iframe>
    </div>
    <divider></divider>
    <div class="pane" id="rendersettings">
      <h3>Directory</h3>

      <h3>Dimensions</h3>
      <div class="input-block">
        <input id="widthIn" name="width" type="number" inputmode="numeric" pattern="\d*" min="1" step="1" value="1920" placeholder="px" required />
        <span>/</span>
        <input id="heightIn" name="height" type="number" inputmode="numeric" pattern="\d*" min="1" step="1" value="1080" placeholder="px" required />
      </div>

      <h3>Duration</h3>
      <div class="input-block">
        <input id="secondsIn" name="seconds" type="number" inputmode="numeric" pattern="\d*" min="1" step="1" value="10" placeholder="sec" required />
        <span style="translate: 0 2px">Ã—</span>
        <input id="fpsIn" name="fps" type="number" inputmode="numeric" pattern="\d*" min="1" step="1" value="25" placeholder="fps" required />
        <span style="translate: 0 2px">=</span>
        <input id="framesIn" name="frames" type="number" inputmode="numeric" pattern="\d*" min="1" step="1" value="250" placeholder="frames" required />
      </div>

      <br>

      <div class="progress-bar" id="renderProgress"></div>
      <button onclick="render()" id="renderButton">Render</button>
      <br><br>
      <button onclick="renderFrame()" id="frameButton">Render Frame</button>

    </div>
  </div>

  <script>
    let dragging = false, draggingDir, startCur, startVal;
    [...document.querySelectorAll('.split')].forEach((split) => {
      const divider = split.querySelector(':scope > divider');
      const resizedPane = split.querySelector(':scope > divider + *');

      divider.addEventListener('mousedown', e => {
        dragging = resizedPane;

        if (split.classList.contains("v")) {
          startCur = e.clientX;
          startVal = resizedPane.getBoundingClientRect().width;
          draggingDir = 'h';
        } else {
          startCur = e.clientY;
          startVal = resizedPane.getBoundingClientRect().height;
          draggingDir = 'v';
        }

        window.addEventListener('mousemove', onMove);
        window.addEventListener('mouseup', onUp);
        window.addEventListener('message', onMessage);

      });

    });

    const iframeLs = new Map();
    document.querySelectorAll('iframe').forEach(iframeL => {
      iframeLs.set(iframeL.contentWindow, iframeL); // same-origin only
    });

    function onMessage(e) {
      const iframeL = iframeLs.get(e.source);
    
      switch (e.data.type) {
        case 'mousemove':
          onMove(e.data, iframeL);
          break;
        case 'mouseup':
          onUp();
          break;
      }
    }

    function onMove(e, iframeL = null) {
      if (!dragging) return;
      currentCur = (draggingDir === 'h') ? e.clientX : e.clientY;
      if (iframeL) {
        const origin = iframeL.getBoundingClientRect();
        currentCur += (draggingDir === 'h') ? origin.left : origin.top;
      }
      dragging.style.flex = '0 0 ' + (startVal + startCur - currentCur) + 'px';
    }

    function onUp() {
      dragging = false;
      document.removeEventListener('mousemove', onMove);
      document.removeEventListener('mouseup', onUp);
      document.removeEventListener('message', onMessage);
    }
  </script>

  <script>
    const widthL = document.getElementById('widthIn');
    const heightL = document.getElementById('heightIn');
    const shaderL = document.getElementById('shaderCanvas');
    
    widthL.addEventListener("change", resizeCanvas); // alt: "input" event
    heightL.addEventListener("change", resizeCanvas);

    function resizeCanvas() {
      shaderL.width = widthL.value;
      shaderL.height= heightL.value;
    }
  </script>

  <script>
    var renderInterval;
    const progBtn = document.getElementById("renderButton");
    const progBar = document.getElementById("renderProgress");


    function render() {
      console.log("rendering...");

      progBtn.innerText = "Stop";
      progBtn.onclick = () => stopRender();

      var prog = 0;
      progBar.classList.add("inprogress");
      progBar.classList.remove("done");
      progBar.style.backgroundPosition = `${100 - prog}%`;
      console.log(`progress: ${prog}%`);
      
      renderInterval = setInterval(() => {
        prog += 13.5;

        progBar.style.backgroundPosition = `${100 - prog}%`;
        console.log(`progress: ${prog}%`);

        if (prog >=100) {
          prog = 100;
          progBar.classList.add("done");
          stopRender('done!');
        }
      }, 700);
    }

    function stopRender(msg = 'stopped by user') {
      clearInterval(renderInterval);
      console.log(msg);
      progBtn.innerText = "Render";
      progBtn.onclick = render;
    }
  </script>

</body>
</html>