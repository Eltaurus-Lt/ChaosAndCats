<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">

  <meta property="og:title" content="GLSL Renderer" />
  <meta property="og:description" content="A GLSL editor focused on deterministic, frame‑by‑frame output rather than real‑time rendering" />
  <meta property="og:image" content="../" />
  <meta property="og:type" content="website" />
  <meta name="twitter:card" content="app" />

  <title>GLSL Renderer</title> 
  <meta name="author" content="Eltaurus">

  <link rel="icon" href="../favicon.svg" type="image/svg+xml">
  <link rel="icon" type="image/svg+xml" href="">
  <link rel="stylesheet" href="../styles/main.css">
  <link rel="stylesheet" href="../styles/Lt.css">

    <!-- CodeMirror -->
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.16/codemirror.min.css">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.16/codemirror.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.16/mode/clike/clike.min.js"></script>
    <!-- CodeMirror addons -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.16/addon/search/searchcursor.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.16/addon/search/search.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.16/keymap/sublime.min.js"></script>

  <style>
    html, body { height: 100%; margin: 0 !important; max-width: unset; padding: 0; outline: unset;}

    #viewportPane, #codePane, #logPane { position: relative; padding: 0 1em; }
    #shaderCanvas {
      position: absolute;
      display: block;
      inset: 50%;
      translate: -50% -50%;
      background: black;

      box-shadow: 5px 5px 25px #0005;

      image-rendering: pixelated;   /* nearest-neighbour */
      image-rendering: crisp-edges; /* nearest-neighbour fallback */
    }
    #viewportPane > :not(#shaderCanvas),
    #codePane > :not(#glslcode),
    #clearButton {
      position: absolute;
      z-index: 100;
    }

    #rendersettings {
      min-width: 110px;
      max-width: 350px;
    }
    #codeSection {
      min-height: 125px;
      max-height: calc(100% - 125px);
    }
    
    
    #codePane {
      padding: 0;
      background: var(--hover-col);
      height: 100%;
    }

    #FileName {
      position: relative;
      /* margin: 0; */
    }
    #FileName:not(:focus-visible):not(:active)::selection {
      background-color: transparent;
    }
    #FileName:not([contenteditable="true"]) {
      user-select: text;          /* Standard */
      -webkit-user-select: text;  /* Chrome/Safari */
      -moz-user-select: text;     /* Firefox */
      -ms-user-select: text;      /* IE/Edge */
    }
    #FileButtons {
      left: 1.25rem;
      top: 3.5rem;
    }

    #logPane {
      background: color-mix(in srgb, black, var(--substrate-col));
      padding: 0;
  
      min-width: 125px;
      max-width: calc(100% - 125px);
    }
    #codePane {
      min-width: 100px;
    }
    #log {
      font-size: 1rem;
      font-family: monospace;
      height: 100%;
      overflow-y: auto;
      margin: 0;
      padding: 4em 1em 1em 2em;
      box-sizing: border-box;
   
      list-style: none;
      counter-reset: item;
    }
    #log > li {
      color: white;
      opacity: .5;
      margin-bottom: 0.5em;
      padding: .5em;
      border-radius: .25em;

      white-space: pre-wrap;

      counter-increment: item;
      position: relative;

      user-select: text;          /* Standard */
      -webkit-user-select: text;  /* Chrome/Safari */
      -moz-user-select: text;     /* Firefox */
      -ms-user-select: text;      /* IE/Edge */
    }
    #log > li ::selection {
      background-color: #fff5;
    }
    #log > li > span {
      overflow-x: auto;
      display: block;
    }
    #log li::before {
      content: counter(item);
      position: absolute;
      right: calc(100% + .5em);
    }
    #log > .error {
      color: color-mix(in srgb, red, white);
      background: #8f1402;
    }
    #log > .success {
      color: color-mix(in srgb, limegreen, white);
      background: forestgreen;
    }

    
    select {
      cursor: pointer;
    }
    .btnGrid > select {
      padding-left: .5em !important;
    }
  </style>

  <style>
    #glslcode {
      height: 100%;
      width: 100%;
      margin: 0;
      padding: 0;
      outline: none;
      font-size: 16px;
    }

    .CodeMirror {
      height: 100%;
      width: 100%;
      
      color: var(--text-col);
      background: var(--hover-col);
    }
    .CodeMirror-scroll {
      overflow: auto !important;
    }

    .CodeMirror-gutters {
      background: var(--hover-col);
      border-color: var(--border-col);
    }
    .CodeMirror-linenumber {
      color: var(--border-col);
    }
 
    .CodeMirror-selected.CodeMirror-selected {
      background-color: #884fd066;
    }

    /* syntax highlights */
    .cm-keyword.cm-keyword   { color: gold; } /* in, out, uniform, if, for, etc. */
    .cm-type.cm-type   { color: var(--accent-col); }
    .cm-atom.cm-atom   { color: #fc0176; }
    .cm-meta.cm-meta { color: #000b; } /* # */
    .cm-builtin.cm-builtin   { color: royalblue; }
    .cm-variable.cm-variable  { color: white; }
    .cm-operator { color: var(--header-col); }
    .cm-number.cm-number    { color: forestgreen; }
    .cm-def.cm-def       { color: red; } 
    .cm-comment.cm-comment   { color: var(--border-text-col); font-style: italic; }
    .cm-string.cm-string    { color: orange; }
    .CodeMirror-cursor { border-color: white; }

  </style>
</head>
<body>
  <div class="split v">
    <div class="split h">
      <div class="pane bg" id="viewportPane">
        <h3 id="FileName" contenteditable="true" spellcheck="false">Untitled</h3>
        <div id="FileButtons" class="btnGrid top left h">
          <button onclick="openFile()" id="openButton" class="btn wide merge">Open</button>
          <button onclick="saveFile()" id="saveButton" class="btn wide">Save</button>
        </div>
        <div id="viewportNavigation" class="btnGrid top right">
          <button onclick = "zoom(zoomLevel - 1)"class="btn merge">-</button>
          <select id="zoomMenu" onchange="zoom(this.selectedIndex)" class="merge"></select>
          <button onclick = "zoom(zoomLevel + 1)" class="btn">+</button>
          <button onclick="zoomFit()" class="btn"><img src="../imgs/site_icons/viewport_expand.svg"/></button>
          <button onclick="zoom(closestLevel(100))" class="btn">1:1</button>
        </div>
        <div id="playbackControls" class="btnGrid bottom center">
          <button onclick="setFrame(0)" class="btn" style="padding-bottom: 1px;">|◀</button>
          <button onclick="setFrame(currentFrame-1)" class="btn merge">&lt;</button>
          <button class="btn toggle merge"><span>(t)</span><span>∫</span></button>
          <input id="frameCount" name="frame" inputmode="numeric" pattern="\d*" step="1" required class=""/>
          <button id="playbackBtn" toggleCallback="togglePlayback" class="btn toggle" style="padding-bottom: 1px;"><span>▶</span><span>||</span></button>
          <button onclick="setFrame(currentFrame+1)" class="btn">&gt;</button>
        </div>
        <div class="buttonGrid bottom right h">
          <button id="frameButton" onclick="saveFrame()" class="merge">Snapshot</button>
        </div>
        <canvas id="shaderCanvas"></canvas>
      </div>
      <divider></divider>
      <div class="split v" id="codeSection" style="flex: 0 0 350px;">
        <div class="pane" id="logPane" style="flex: 0 0 40%;">
          <button id="clearButton" onclick="clearLog()" class="top right">Clear</button>
          <ol id="log"></ol>
        </div>
        <divider></divider>
        <div class="pane" id="codePane">
          <button onclick="compile()" id="compileButton" class="top right">Compile</button>
          <div id="glslcode"><textarea id="editor">precision highp float;
uniform float iTime;
uniform int iFrame;
uniform vec2 iResolution;

void main() {
  vec2 uv = gl_FragCoord.xy / iResolution.xy;
  vec3 col = vec3(uv, 0.5 + 0.5*sin(iTime));
  vec3 plot;
  
  if (uv.y > .5 + 0.2 * sin(10.* uv.x + iTime) ) {
    plot = col;
  } else {
    plot = vec3(0);
  }

  gl_FragColor = vec4(plot, 1.0);
}</textarea></div>
        </div>
      </div>
    </div>
    <divider></divider>
    <div class="pane Lt" id="rendersettings" style="flex: 0 0 250px;">
      <h3 hidden>Directory</h3>

      <h3>Dimensions</h3>
      <div class="input-block">
        <input id="widthIn" name="width" type="number" inputmode="numeric" pattern="\d*" min="1" step="1" value="960" placeholder="px" required />
        <span>/</span>
        <input id="heightIn" name="height" type="number" inputmode="numeric" pattern="\d*" min="1" step="1" value="540" placeholder="px" required />
      </div>

      <h3>Duration</h3>
      <div class="input-block">
        <input id="secondsIn" name="seconds" type="number" inputmode="numeric" pattern="\d*" min="1" step="any" value="10" placeholder="sec" required />
        <span style="translate: 0 2px">×</span>
        <input id="fpsIn" name="fps" type="number" inputmode="numeric" pattern="\d*" min="1" step="0.01" value="25" placeholder="fps" required />
        <span style="translate: 0 2px">=</span>
        <input id="framesIn" name="frames" type="number" inputmode="numeric" pattern="\d*" min="1" step="1" value="250" placeholder="frames" required />
      </div>

      <h3>Format</h3>
      <div id="formatSelect" class="input-block single-choice">
        <button class="merge btn wide">PNG</button><button class="btn wide">EXR</button>
      </div>

      <br>
      <div class="progress-bar" id="renderProgress"></div>
      <button id="renderButton" onclick="render()">Render</button>

    </div>
  </div>

  <script>
    let resizedPane = false, dragging, draggingSign, startCur, startVal;
    [...document.querySelectorAll('.split')].forEach((split) => {
      const divider = split.querySelector(':scope > divider');
      const firstPane = split.querySelector(':scope > :first-child');
      const lastPane = split.querySelector(':scope > :last-child');

      divider.addEventListener('mousedown', e => {
        if (firstPane.style.flexBasis) { // decide which half gets a fixed width depending on flex-basis value
          draggingSign = -1;
          resizedPane = firstPane; 
        } else {
          draggingSign = 1;
          resizedPane = lastPane; 
        }

        if (split.classList.contains("v")) {
          startCur = e.clientX;
          startVal = resizedPane.getBoundingClientRect().width;
          dragging = 'h';
        } else {
          startCur = e.clientY;
          startVal = resizedPane.getBoundingClientRect().height;
          dragging = 'v';
        }

        window.addEventListener('mousemove', onMove);
        window.addEventListener('mouseup', onUp);
        window.addEventListener('message', onMessage);

      });

    });

    const iframeLs = new Map();
    document.querySelectorAll('iframe').forEach(iframeL => {
      iframeLs.set(iframeL.contentWindow, iframeL); // same-origin only
    });

    function onMessage(e) {
      const iframeL = iframeLs.get(e.source);
    
      switch (e.data.type) {
        case 'mousemove':
          onMove(e.data, iframeL);
          break;
        case 'mouseup':
          onUp();
          break;
      }
    }

    function onMove(e, iframeL = null) {
      if (!resizedPane) return;
      currentCur = (dragging === 'h') ? e.clientX : e.clientY;
      if (iframeL) {
        const origin = iframeL.getBoundingClientRect();
        currentCur += (dragging === 'h') ? origin.left : origin.top;
      }
      resizedPane.style.flex = `0 0 ${Math.max(startVal + draggingSign * (startCur - currentCur), 62)}px`;
    }

    function onUp() {
      resizedPane = false;
      document.removeEventListener('mousemove', onMove);
      document.removeEventListener('mouseup', onUp);
      document.removeEventListener('message', onMessage);
    }
  </script>

  <script>
    [...document.querySelectorAll("button.toggle")].forEach((btnL)=>{
      btnL.addEventListener('click', () => {
        btnL.classList.toggle('pressed');
        const callbackFunction = window[btnL.getAttribute('toggleCallback')];
        if (typeof callbackFunction === "function") {
          callbackFunction();
        }
      });
    })
  </script>

  <script>
    CodeMirror.fromTextArea(document.getElementById("editor"), {
      mode: "x-shader/x-fragment",
      lineNumbers: true,
      matchBrackets: true,
      keyMap: "sublime",
      extraKeys: {
        "Ctrl-D": "selectNextOccurrence",
        "Ctrl-Enter": cm => cm.state.keyEvent?.preventDefault()
      },
      indentUnit: 2
    });
  </script>
  
  <script>
    function getCode() {
      return document.getElementById('glslcode').querySelector('.CodeMirror').CodeMirror.getValue()
    }

    function getName() {
      return document.getElementById('FileName').innerText;
    }

    function nameCleanup(name) {
      return name.replace(/\.[^.]+$/, "").replace(/\(\d+\)$/, "");
    }
   
    function setNameAndCode(name, code) {
      document.getElementById('FileName').innerText = nameCleanup(name);
      document.querySelector(".CodeMirror").CodeMirror.setValue(code);
    }

    function openFile() {
      // console.log('opening...');
      const input = document.createElement("input");
      input.type = "file";
      input.accept = ".glsl,.frag";

      input.onchange = () => {
        const file = input.files[0];
        const reader = new FileReader();
        reader.onload = e => {
          setNameAndCode(file.name, e.target.result);
        }
        reader.readAsText(file)
      }

      input.click();

    }
    
    function saveFile() {
      // console.log('saving...');
      const url = URL.createObjectURL(new Blob([getCode()], {type:"text/plain"}));
      const tempL = Object.assign(document.createElement("a"), {href:url, download: `${getName()}.glsl`});
      tempL.click();
      URL.revokeObjectURL(url);
    }
 
  </script>

  <script>
    const widthL = document.getElementById('widthIn');
    const heightL = document.getElementById('heightIn');
    const shaderL = document.getElementById('shaderCanvas');
    
    widthL.addEventListener("change", resizeCanvas); // alt: "input" event
    heightL.addEventListener("change", resizeCanvas);

    function resizeCanvas() {
      shaderL.width = widthL.value;
      shaderL.height= heightL.value;
    }

  </script>

  <script>
    const secondsL = document.getElementById('secondsIn');
    const fpsL = document.getElementById('fpsIn');
    const framesL = document.getElementById('framesIn');

    secondsL.addEventListener("change", ()=>{ framesL.value = Math.round(fpsL.value * secondsL.value); }); 
    fpsL.addEventListener("change", ()=>{ framesL.value = Math.round(fpsL.value * secondsL.value); }); 
    framesL.addEventListener("change", ()=>{ secondsL.value = Number((framesL.value / fpsL.value).toFixed(4)); }); 
  </script>

  <script>
    var renderInterval;
    const progBtn = document.getElementById("renderButton");
    const progBar = document.getElementById("renderProgress");


    function render() {
      console.log("rendering...");

      progBtn.innerText = "Stop";
      progBtn.onclick = () => stopRender();

      var prog = 0;
      progBar.classList.add("inprogress");
      progBar.classList.remove("done");
      progBar.style.backgroundPosition = `${100 - prog}%`;
      console.log(`progress: ${prog}%`);
      
      renderInterval = setInterval(() => {
        prog += 13.5;

        progBar.style.backgroundPosition = `${100 - prog}%`;
        console.log(`progress: ${prog}%`);

        if (prog >=100) {
          prog = 100;
          progBar.classList.add("done");
          stopRender('done!');
        }
      }, 700);
    }

    function stopRender(msg = 'stopped by user') {
      clearInterval(renderInterval);
      console.log(msg);
      progBtn.innerText = "Render";
      progBtn.onclick = render;
    }
  </script>

  <script>
    // playback functions
    let currentFrame = 0;

    function cleanNumber(numberString, isInteger = false) {
      const number = parseFloat(numberString.replace(/[^0-9.]/g,""));
      return isInteger ? Math.round(number) : number;
    }

    function setFrame(newFrame) {
      currentFrame = newFrame;
      requestAnimationFrame(displayFrame);
    }

    const frameCountL = document.getElementById('frameCount');
    frameCountL.addEventListener("change", ()=>{
      const cleanFrameCount = cleanNumber(frameCountL.value, true);
      frameCountL.blur();
      setFrame(cleanFrameCount);
    }); 

    let playback = false;
    const playbackL = document.getElementById('playbackBtn');
    function togglePlayback() {
      playback = playbackL.classList.contains('pressed');
      if (playback) {
        requestAnimationFrame(displayFrame);
      }
    }
  </script>

  <script>
    const gl = shaderL.getContext("webgl2", { preserveDrawingBuffer: true });
    let program = null, iResolutionLoc, iTimeLoc, iFrameLoc;
    let startTime = performance.now();


    function displayFrame() {
      if (!program) return;

      gl.viewport(0, 0, shaderL.width, shaderL.height);
      gl.useProgram(program);

      // const now = performance.now();
      // const time = (now - startTime) * 0.001;

      const time = currentFrame / fpsL.value;

      if (iResolutionLoc) {
        gl.uniform2f(iResolutionLoc, shaderL.width, shaderL.height);
      }
      if (iTimeLoc) {
        gl.uniform1f(iTimeLoc, time);
      }
      if (iFrameLoc) {
        gl.uniform1i(iFrameLoc, currentFrame);
      }

      frameCountL.value = currentFrame;
      gl.drawArrays(gl.TRIANGLES, 0, 3);
      if (playback) {
        currentFrame++;
        requestAnimationFrame(displayFrame);
      }
    }

    function loadShader(type, source) {
      const shader = gl.createShader(type);
      gl.shaderSource(shader, source);
      gl.compileShader(shader);
      if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
        const info = gl.getShaderInfoLog(shader);
        log(`${info}`, 'error'); // Shader compile error: 
        gl.deleteShader(shader);
        return null;
      }
      return shader;
    }

    function compile() {
      const code = getCode();

      const vertexSource = `
        attribute vec2 aPosition;
        void main() {
          gl_Position = vec4(aPosition, 0.0, 1.0);
        }
      `;

      const fragmentSource = `${code}`;

      // init program
      const vs = loadShader(gl.VERTEX_SHADER, vertexSource);
      const fs = loadShader(gl.FRAGMENT_SHADER, fragmentSource);
      if (!vs || !fs) return;

      if (program) {
        gl.useProgram(null);
        gl.deleteProgram(program);
      }
      program = gl.createProgram();
      gl.attachShader(program, vs);
      gl.attachShader(program, fs);
      gl.linkProgram(program);
      if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
        const info = gl.getProgramInfoLog(program);
        log(`Program link error: ${info}`, 'error');
        gl.deleteProgram(program);
        return;
      }
      gl.useProgram(program);

      const buffer = gl.createBuffer();
      gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
      const vertices = new Float32Array([-1,-1,3,-1,-1,3]);
      gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);

      const aPosition = gl.getAttribLocation(program, 'aPosition');
      gl.enableVertexAttribArray(aPosition);
      gl.vertexAttribPointer(aPosition, 2, gl.FLOAT, false, 0, 0);

      iResolutionLoc = gl.getUniformLocation(program, 'iResolution');
      iTimeLoc       = gl.getUniformLocation(program, 'iTime');
      iFrameLoc      = gl.getUniformLocation(program, 'iFrame');

      log("Compiled successfully!", 'success');

      requestAnimationFrame(displayFrame);
    }
  </script>

  <script>
    // Log
    function log(message, classList = '') {
      const logEntry = document.createElement("li");
      logEntry.innerHTML = `<span>${message}</span>`;
      if (classList) {
        logEntry.classList.add(classList);
      }

      const logL = document.getElementById('log');
      logL.appendChild(logEntry);
      logL.scrollTop = logL.scrollHeight;
    }

    function clearLog() {
console.log('clearing...');
      document.getElementById('log').innerHTML = "";
    }
  </script>

  <script>
    // Exporting

    function frameNumber(frame = '') {
      if (!frame) {
        frame = currentFrame;
      }
      return String(frame).padStart(4, '0');
    }

    function saveFrame(path = '') {

      //gl.flush();

      const tempL = document.createElement("a");
      tempL.download = path ? path : `${getName()}_${frameNumber()}.png`;
      tempL.href = shaderL.toDataURL("image/png");
      tempL.click();
    }
  </script>

  <script>
    // Viewport navigation

    zoomList = [10, 25, 50, 100, 200, 400, 700, 1000];

    const zoomMenu = document.getElementById('zoomMenu');    
    zoomList.forEach(zoomLevel => {
      const zoomItem = document.createElement("option");
      zoomItem.value = zoomLevel;
      zoomItem.textContent = `${zoomLevel}%`;
      zoomMenu.appendChild(zoomItem);
    })

    let zoomLevel;
  
    const viewportL = document.getElementById('viewportPane');

    viewportL.addEventListener("wheel", e => {
      zoomLevel -= Math.sign(e.deltaY);
      zoom(zoomLevel);
    });

    function closestLevel(targetZoom) {
        let closestI = 0;
        let closest = Math.abs(zoomList[0] - targetZoom);
        for (let i = 1; i < zoomList.length; i++) {
          const diff = Math.abs(zoomList[i] - targetZoom);
          if (diff < closest) {
            closest = diff;
            closestI = i;
          }
        }
        return closestI;
    }

    function zoom(zoomTarget) {
      if (zoomTarget === undefined) {
        zoomLevel = closestLevel(100);
      } else {
        zoomLevel = Math.min(Math.max(Math.round(zoomTarget), 0), zoomList.length - 1);
      }
      zoomMenu.selectedIndex = zoomLevel;
      shaderL.style.scale = `${zoomList[zoomLevel]}%`;
    }
 
    function zoomFit() {
      const dimensions = document.getElementById('viewportPane').getBoundingClientRect(); 
      const idealZoom = 100 * Math.min(
        dimensions.width / shaderL.width,
        dimensions.height / shaderL.height
      );
      const targetLevel = closestLevel(idealZoom);
      zoom(zoomList[targetLevel] <= idealZoom ? targetLevel : targetLevel-1 );
    }

  </script>

  <script>
    // INIT

    const params = new URLSearchParams(window.location.search);
    const source = params.get("src");
    if (source) {
      fetch(`../shaders/${source}`)
         .then(r => r.text())
        .then(srcCode => {
          setNameAndCode(source, srcCode);
        });
    }
    if (params.get("width")) {widthL.value = Math.round(params.get("width"));}
    if (params.get("height")) {heightL.value = Math.round(params.get("height"));}

    resizeCanvas();
    zoom();
    setTimeout(()=>{
      compile();
      playbackL.click();
    }, 500);
  </script>

  <script>
    // Keyboard Shortcuts
    window.addEventListener('keydown', (e) => {

      /* avoid triggering when editing text */
      const tag = (e.target.tagName || '').toLowerCase();
      const editable = e.target.isContentEditable || tag === 'input' || tag === 'textarea';

      const ctrlKey = e.ctrlKey || e.metaKey; /* ctrl || mac cmd */
      const shiftKey = e.shiftKey;
      const altKey = e.altKey;
      const key = e.key;
      if (key === 'Enter' && e.target.id === 'FileName') {
        e.preventDefault();
        e.target.blur();
      }
      if (editable && !ctrlKey) return;

      /* Open */
      if (ctrlKey && !shiftKey && key === 'o') {
        e.preventDefault();
        openFile();
        return;
      }

      /* Save */
      if (ctrlKey && !shiftKey && key === 's') {
        e.preventDefault();
        saveFile();
        return;
      }

      /* zoom+ */
      if (key === '=') {
        e.preventDefault();
        zoom(zoomLevel + 1);
        return;
      }
      /* zoom- */
      if (key === '-') {
        e.preventDefault();
        zoom(zoomLevel - 1);
        return;
      }

      /* zoom to fit */
      if ((ctrlKey || altKey) && !shiftKey && key === 'f') {
        e.preventDefault();
        zoomFit();
        return;
      }

      /* Reset zoom */
      if (altKey && key === 's') {
        e.preventDefault();
        zoom();
        return;
      }

      /* Compile */
      if (ctrlKey && key === 'Enter') {
        e.preventDefault();
        compile();
        return;
      }

      /* Clear log */
      if (ctrlKey && key === 'l') {
        e.preventDefault();
        clearLog();
        return;
      }

      /* playback */
      if (key === ' ') {
        playbackL.click();
      }
      if (key === '<' || key === ',' || key === 'ArrowLeft') {
        e.preventDefault();
        setFrame(currentFrame-1);
      }
      if (key === '>' || key === '.' || key === 'ArrowRight') {
        e.preventDefault();
        setFrame(currentFrame+1);
      }
      if (key === 'ArrowDown') {
        e.preventDefault();
        setFrame(0);
      }
      if (key === 'ArrowUp') {
        e.preventDefault();
        setFrame(cleanNumber(framesL.value,true));
      }


    });
  </script>
</body>
</html>